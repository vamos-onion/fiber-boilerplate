// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: appuser.sql

package models

import (
	"context"

	null "gopkg.in/guregu/null.v4"
)

const createAppuser = `-- name: CreateAppuser :one
INSERT INTO appuser (name, birthday, gender, withdraw)
VALUES ($1, $2, $3, $4)
RETURNING id, uuid, created_at, modified_at, name, birthday, gender, withdraw
`

type CreateAppuserParams struct {
	Name     null.String `db:"name"`
	Birthday null.Time   `db:"birthday"`
	Gender   null.String `db:"gender"`
	Withdraw null.Bool   `db:"withdraw"`
}

func (q *Queries) CreateAppuser(ctx context.Context, arg CreateAppuserParams) (AppuserBlock, error) {
	row := q.db.QueryRowContext(ctx, createAppuser,
		arg.Name,
		arg.Birthday,
		arg.Gender,
		arg.Withdraw,
	)
	var i AppuserBlock
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Name,
		&i.Birthday,
		&i.Gender,
		&i.Withdraw,
	)
	return i, err
}

const getAllAppusers = `-- name: GetAllAppusers :many
SELECT id, uuid, created_at, modified_at, name, birthday, gender, withdraw
FROM appuser
`

func (q *Queries) GetAllAppusers(ctx context.Context) ([]AppuserBlock, error) {
	rows, err := q.db.QueryContext(ctx, getAllAppusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppuserBlock
	for rows.Next() {
		var i AppuserBlock
		if err := rows.Scan(
			&i.ID,
			&i.UUID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Name,
			&i.Birthday,
			&i.Gender,
			&i.Withdraw,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppusersByName = `-- name: GetAppusersByName :one
SELECT id, uuid, created_at, modified_at, name, birthday, gender, withdraw
FROM appuser
WHERE name = $1
`

func (q *Queries) GetAppusersByName(ctx context.Context, name null.String) (AppuserBlock, error) {
	row := q.db.QueryRowContext(ctx, getAppusersByName, name)
	var i AppuserBlock
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Name,
		&i.Birthday,
		&i.Gender,
		&i.Withdraw,
	)
	return i, err
}

const searchAppusers = `-- name: SearchAppusers :many
SELECT id, uuid, created_at, modified_at, name, birthday, gender, withdraw
FROM appuser
WHERE ($1::varchar IS NULL OR uuid = CAST($1 AS UUID))
  AND ($2::varchar IS NULL OR name = $2)
  AND ($3::enum_gender IS NULL OR gender = $3)
  AND ($4::boolean IS NULL OR withdraw = $4)
          ? 1 = $5::text
`

type SearchAppusersParams struct {
	UUID     null.String `db:"uuid"`
	Name     null.String `db:"name"`
	Gender   null.String `db:"gender"`
	Withdraw null.Bool   `db:"withdraw"`
	Options  null.String `db:"options"`
}

func (q *Queries) SearchAppusers(ctx context.Context, arg SearchAppusersParams) ([]AppuserBlock, error) {
	rows, err := q.db.QueryContext(ctx, searchAppusers,
		arg.UUID,
		arg.Name,
		arg.Gender,
		arg.Withdraw,
		arg.Options,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppuserBlock
	for rows.Next() {
		var i AppuserBlock
		if err := rows.Scan(
			&i.ID,
			&i.UUID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Name,
			&i.Birthday,
			&i.Gender,
			&i.Withdraw,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppuser = `-- name: UpdateAppuser :one
UPDATE appuser
SET name     = $2,
    birthday = $3,
    gender   = $4,
    withdraw = $5
WHERE appuser.uuid = $1
RETURNING id, uuid, created_at, modified_at, name, birthday, gender, withdraw
`

type UpdateAppuserParams struct {
	UUID     null.String `db:"uuid"`
	Name     null.String `db:"name"`
	Birthday null.Time   `db:"birthday"`
	Gender   null.String `db:"gender"`
	Withdraw null.Bool   `db:"withdraw"`
}

func (q *Queries) UpdateAppuser(ctx context.Context, arg UpdateAppuserParams) (AppuserBlock, error) {
	row := q.db.QueryRowContext(ctx, updateAppuser,
		arg.UUID,
		arg.Name,
		arg.Birthday,
		arg.Gender,
		arg.Withdraw,
	)
	var i AppuserBlock
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.Name,
		&i.Birthday,
		&i.Gender,
		&i.Withdraw,
	)
	return i, err
}
